name: Self-Repair

on:
  workflow_run:
    workflows: ["*"]
    types: [completed]
  workflow_dispatch:
    inputs:
      run_id:
        description: 'Workflow run ID to repair (optional, uses latest failed if empty)'
        required: false
        type: string
  schedule:
    - cron: '*/30 * * * *'  # Check every 30 minutes for any failures

permissions:
  contents: write
  pull-requests: write
  actions: read
  checks: read

jobs:
  self-repair:
    # Only run if a workflow failed, or if manually triggered, or on schedule
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'failure')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Find failed workflow run
        id: find_failure
        run: |
          # Determine which run to repair
          if [ -n "${{ github.event.inputs.run_id }}" ]; then
            RUN_ID="${{ github.event.inputs.run_id }}"
            echo "Using provided run ID: $RUN_ID"
          elif [ "${{ github.event_name }}" = "workflow_run" ]; then
            RUN_ID="${{ github.event.workflow_run.id }}"
            echo "Using triggering workflow run ID: $RUN_ID"
          else
            # Find most recent failed run
            RUN_ID=$(gh run list --limit 50 --json conclusion,databaseId \
              --jq '.[] | select(.conclusion == "failure") | .databaseId' | head -1)
            if [ -z "$RUN_ID" ]; then
              echo "No failed runs found"
              echo "has_failure=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Found most recent failed run: $RUN_ID"
          fi

          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          echo "has_failure=true" >> $GITHUB_OUTPUT

          # Get workflow details
          WORKFLOW_NAME=$(gh run view "$RUN_ID" --json name --jq '.name' 2>/dev/null || echo "unknown")
          echo "workflow_name=$WORKFLOW_NAME" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Prepare repair context
        if: steps.find_failure.outputs.has_failure == 'true'
        id: context
        run: |
          RUN_ID="${{ steps.find_failure.outputs.run_id }}"

          # Make handler executable
          chmod +x scripts/fix-workflows-handler.sh

          # Run handler to prepare context
          ./scripts/fix-workflows-handler.sh "$RUN_ID" > handler_output.txt

          # Extract paths from handler output
          source handler_output.txt

          echo "context_file=$REPAIR_CONTEXT_FILE" >> $GITHUB_OUTPUT
          echo "analysis_dir=$ANALYSIS_DIR" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Claude analyzes and repairs workflow
        if: steps.find_failure.outputs.has_failure == 'true'
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: |
            üîß **WORKFLOW SELF-REPAIR MODE ACTIVATED**

            A workflow has failed and needs your expert analysis and repair.

            **Failed Workflow**: ${{ steps.find_failure.outputs.workflow_name }}
            **Run ID**: ${{ steps.find_failure.outputs.run_id }}
            **View Run**: https://github.com/${{ github.repository }}/actions/runs/${{ steps.find_failure.outputs.run_id }}

            Read the complete repair context from: ${{ steps.context.outputs.context_file }}

            This file contains:
            - Full run details and metadata
            - Complete failure logs
            - Common issues checklist
            - Your repair instructions

            **Your Mission**:
            1. Read and analyze the repair context file
            2. Identify the root cause of the failure
            3. Implement the appropriate fix:
               - Fix workflow YAML if it's a configuration issue
               - Create missing files (e.g., data.json) if needed
               - Add error handling or retries if it's a transient issue
               - Update documentation if manual setup is required
            4. For simple fixes: Commit directly to main
            5. For complex changes: Create a PR with detailed description

            **Important**:
            - If the issue requires manual setup (like enabling GitHub Pages or adding secrets),
              create a GitHub Issue with clear setup instructions instead
            - Check if data.json exists - create it with initial content if missing
            - Consider if the workflow needs better error handling
            - Think about whether the schedule is too aggressive (rate limits?)

            **After Fixing**:
            Provide a clear summary of:
            - What was broken
            - What you fixed
            - How you fixed it (commit/PR/issue)
            - Any follow-up actions needed

            Let's fix this workflow! üõ†Ô∏è
          create_pr: false  # Let Claude decide based on complexity

      - name: Notify success
        if: steps.find_failure.outputs.has_failure == 'true'
        run: |
          echo "‚úÖ Claude self-repair completed for run ${{ steps.find_failure.outputs.run_id }}"
          echo "   Workflow: ${{ steps.find_failure.outputs.workflow_name }}"
          echo ""
          echo "Check the Claude Code Action output above for details on the fix."
